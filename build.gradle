plugins {
    id 'java-library'
    id 'maven-publish'
    id 'net.neoforged.moddev' version '2.0.126'
    id 'idea'
}

// Define the Wrapper task to customize the Gradle wrapper
// 定义包装器任务以自定义Gradle包装器
tasks.named('wrapper', Wrapper).configure {
    // Define wrapper values here so as to not have to always do so when updating gradlew.properties.
    // Switching this to Wrapper.DistributionType.ALL will download the full gradle sources that comes with
    // documentation attached on cursor hover of gradle classes and methods. However, this comes with increased
    // file size for Gradle. If you do switch this to ALL, run the Gradle wrapper task twice afterwards.
    // (Verify by checking gradle/wrapper/gradle-wrapper.properties to see if distributionUrl now points to `-all`)
    // 在这里定义包装器值，这样在更新gradlew.properties时就不必总是这样做。
    // 将其切换为Wrapper.DistributionType.ALL将下载完整的Gradle源代码，其中包括悬停在Gradle类和方法上时附带的文档。
    // 但是，这会增加Gradle的文件大小。如果你确实要切换到ALL，请随后运行Gradle包装器任务两次。
    // （通过检查gradle/wrapper/gradle-wrapper.properties验证distributionUrl现在是否指向`-all`）
    distributionType = Wrapper.DistributionType.BIN
}

version = mod_version
group = "com.github.chromabreak"  // Consider using your mod_id or reverse domain
// 考虑使用你的mod_id或反向域名

repositories {
    mavenCentral()

    // Official KubeJS Maven repository (required)
    // KubeJS 官方 Maven 仓库（必须）
    maven {
        url "https://maven.latvian.dev/releases"
        content {
            includeGroup "dev.latvian.mods"
            includeGroup "dev.latvian.apps"
        }
    }

    // Rhino and other dependencies (KubeJS may need)
    // Rhino 等依赖（KubeJS 可能需要）
    maven {
        url 'https://jitpack.io'
        content {
            includeGroup "com.github.rtyley"
        }
    }

    // Modrinth Maven (for mods like Lychee, Architectury, JEI, etc.)
    // Modrinth Maven（用于 Lychee、Architectury、JEI 等模组）
    maven {
        url "https://maven.modrinth.com/releases"
        content {
            includeGroup "maven.modrinth"
        }
    }
}

base {
    archivesName = mod_id
}

// Mojang ships Java 21 to end users in 1.21.1, so mods should target Java 21.
// Mojang 在 1.21.1 中向最终用户提供 Java 21，因此模组应面向 Java 21。
java.toolchain.languageVersion = JavaLanguageVersion.of(21)

neoForge {
    // Specify the version of NeoForge to use.
    // 指定要使用的 NeoForge 版本。
    version = project.neo_version

    // Parchment mappings for better parameter names and javadoc
    // Parchment 映射，用于获取更好的参数名和 Javadoc
    parchment {
        minecraftVersion = project.parchment_minecraft_version
        mappingsVersion = project.parchment_mappings_version
    }

    // This line is optional. Access Transformers are automatically detected
    // 此行是可选的。访问转换器会自动检测
    // accessTransformers = project.files('src/main/resources/META-INF/accesstransformer.cfg')

    // Default run configurations.
    // These can be tweaked, removed, or duplicated as needed.
    // 默认运行配置。
    // 可以根据需要调整、删除或复制这些配置。
    runs {
        client {
            client()

            // Comma-separated list of namespaces to load gametests from. Empty = all namespaces.
            // 逗号分隔的命名空间列表，用于从中加载游戏测试。空值 = 所有命名空间。
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
        }

        server {
            server()
            programArgument '--nogui'
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
        }

        // This run config launches GameTestServer and runs all registered gametests, then exits.
        // By default, the server will crash when no gametests are provided.
        // The gametest system is also enabled by default for other run configs under the /test command.
        // 此运行配置启动 GameTestServer 并运行所有已注册的游戏测试，然后退出。
        // 默认情况下，当没有提供游戏测试时，服务器将崩溃。
        // 游戏测试系统也默认在其他运行配置的 /test 命令下启用。
        gameTestServer {
            type = "gameTestServer"
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
        }

        data {
            data()

            // example of overriding the workingDirectory set in configureEach above, uncomment if you want to use it
            // 覆盖上面 configureEach 中设置的工作目录的示例，如果需要使用请取消注释
            // gameDirectory = project.file('run-data')

            // Specify the modid for data generation, where to output the resulting resource, and where to look for existing resources.
            // 指定用于数据生成的模组ID，输出生成的资源的位置，以及查找现有资源的位置。
            programArguments.addAll '--mod', project.mod_id, '--all', '--output', file('src/generated/resources/').getAbsolutePath(), '--existing', file('src/main/resources/').getAbsolutePath()
        }

        // applies to all the run configs above
        // 适用于上述所有运行配置
        configureEach {
            // Recommended logging data for a userdev environment
            // The markers can be added/remove as needed separated by commas.
            // "SCAN": For mods scan.
            // "REGISTRIES": For firing of registry events.
            // "REGISTRYDUMP": For getting the contents of all registries.
            // 用户开发环境推荐的日志数据
            // 可以根据需要添加/删除标记，用逗号分隔。
            // "SCAN": 用于模组扫描。
            // "REGISTRIES": 用于触发注册表事件。
            // "REGISTRYDUMP": 用于获取所有注册表的内容。
            systemProperty 'forge.logging.markers', 'REGISTRIES'

            // Recommended logging level for the console
            // You can set various levels here.
            // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
            // 控制台推荐的日志级别
            // 您可以在此设置各种级别。
            // 请阅读：https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
            systemProperty 'forge.logging.console.level', 'debug'
        }
    }

    mods {
        // define mod <-> source bindings
        // these are used to tell the game which sources are for which mod
        // multi mod projects should define one per mod
        // 定义模组 <-> 源代码绑定
        // 这些用于告诉游戏哪些源代码属于哪个模组
        // 多模组项目应为每个模组定义一个
        "${mod_id}" {
            sourceSet(sourceSets.main)
        }
    }
}

// Include resources generated by data generators.
// 包含数据生成器生成的资源。
sourceSets.main.resources { srcDir 'src/generated/resources' }

// Sets up a dependency configuration called 'localRuntime'.
// This configuration should be used instead of 'runtimeOnly' to declare
// a dependency that will be present for runtime testing but that is
// "optional", meaning it will not be pulled by dependents of this mod.
// 设置一个名为 'localRuntime' 的依赖配置。
// 应使用此配置而不是 'runtimeOnly' 来声明将在运行时测试中存在但为"可选"的依赖项，
// 这意味着此模组的依赖项不会拉取它。
configurations {
    runtimeClasspath.extendsFrom localRuntime
}

dependencies {
    // KubeJS dependency - compileOnly for API access, runtimeOnly for runtime (needed for client classes)
    // KubeJS 依赖 - compileOnly 用于 API 访问，runtimeOnly 用于运行时（客户端类需要）
    compileOnly("dev.latvian.mods:kubejs-neoforge:${kubejs_version}")
    runtimeOnly("dev.latvian.mods:kubejs-neoforge:${kubejs_version}")

    // ✅ CORRECT: Interface injection data for development environment
    // ✅ 正确：用于开发环境的接口注入数据
    interfaceInjectionData("dev.latvian.mods:kubejs-neoforge") {
        version {
            strictly "[${kubejs_version}]"
        }
    }

    // Gson for JSON parsing in entity configuration
    // Gson 用于实体配置中的 JSON 解析
    implementation("com.google.code.gson:gson:2.10.1")

    // Lychee mod dependency (optional, user needs to add manually)
    // Lychee 模组依赖（可选，用户需要手动添加）
    // localRuntime "maven.modrinth:lychee:VERSION"

    // Example optional mod dependency with JEI
    // The JEI API is declared for compile time use, while the full JEI artifact is used at runtime
    // 使用 JEI 的示例可选模组依赖
    // JEI API 声明用于编译时使用，而完整的 JEI 构件用于运行时
    // compileOnly "mezz.jei:jei-${mc_version}-common-api:${jei_version}"
    // compileOnly "mezz.jei:jei-${mc_version}-neoforge-api:${jei_version}"
    // We add the full version to localRuntime, not runtimeOnly, so that we do not publish a dependency on it
    // 我们将完整版本添加到 localRuntime，而不是 runtimeOnly，这样我们就不会发布对它的依赖
    // localRuntime "mezz.jei:jei-${mc_version}-neoforge:${jei_version}"

    // Example mod dependency using a mod jar from ./libs with a flat dir repository
    // This maps to ./libs/coolmod-${mc_version}-${coolmod_version}.jar
    // The group id is ignored when searching -- in this case, it is "blank"
    // 使用来自 ./libs 的模组 JAR 和平面目录仓库的示例模组依赖
    // 这映射到 ./libs/coolmod-${mc_version}-${coolmod_version}.jar
    // 搜索时忽略组ID——在这种情况下，它是"blank"
    // implementation "blank:coolmod-${mc_version}:${coolmod_version}"

    // Example mod dependency using a file as dependency
    // 使用文件作为依赖的示例模组依赖
    // implementation files("libs/coolmod-${mc_version}-${coolmod_version}.jar")

    // Example project dependency using a sister or child project:
    // 使用同级或子项目的示例项目依赖：
    // implementation project(":myproject")

    // For more info:
    // 更多信息：
    // http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
    // http://www.gradle.org/docs/current/userguide/dependency_management.html
}

// This block of code expands all declared replace properties in the specified resource targets.
// A missing property will result in an error. Properties are expanded using ${} Groovy notation.
// 此代码块展开指定资源目标中所有声明的替换属性。
// 缺少属性将导致错误。属性使用 ${} Groovy 表示法展开。
var generateModMetadata = tasks.register("generateModMetadata", ProcessResources) {
    var replaceProperties = [
            minecraft_version      : minecraft_version,
            minecraft_version_range: minecraft_version_range,
            neo_version            : neo_version,
            loader_version_range   : loader_version_range,
            mod_id                 : mod_id,
            mod_name               : mod_name,
            mod_license            : mod_license,
            mod_version            : mod_version,
            mod_authors            : mod_authors,
            mod_description        : mod_description
    ]
    inputs.properties replaceProperties
    expand replaceProperties
    from "src/main/templates"
    into "build/generated/sources/modMetadata"
}
// Include the output of "generateModMetadata" as an input directory for the build
// this works with both building through Gradle and the IDE.
// 将 "generateModMetadata" 的输出作为构建的输入目录包含
// 这适用于通过 Gradle 和 IDE 进行构建。
sourceSets.main.resources.srcDir generateModMetadata
// To avoid having to run "generateModMetadata" manually, make it run on every project reload
// 为了避免手动运行 "generateModMetadata"，使其在每次项目重新加载时运行
neoForge.ideSyncTask generateModMetadata

// Example configuration to allow publishing using the maven-publish plugin
// 允许使用 maven-publish 插件进行发布的示例配置
publishing {
    publications {
        register('mavenJava', MavenPublication) {
            from components.java
        }
    }
    repositories {
        maven {
            url "file://${project.projectDir}/repo"
        }
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8' // Use the UTF-8 charset for Java compilation
    // 使用 UTF-8 字符集进行 Java 编译
}

// IDEA no longer automatically downloads sources/javadoc jars for dependencies, so we need to explicitly enable the behavior.
// IDEA 不再自动下载依赖项的源代码/Javadoc JAR，因此我们需要显式启用此行为。
idea {
    module {
        downloadSources = true
        downloadJavadoc = true
    }
}